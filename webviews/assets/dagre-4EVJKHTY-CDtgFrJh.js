import{_ as m,av as M,aw as j,ax as F,ay as Y,l as i,d as H,az as z,aA as _,ah as q,am as K,ai as O,ag as Q,aB as U,aC as V,aD as W}from"./AugmentMessage-x438MRdb.js";import{G as k}from"./graph-D4UWwI0Q.js";import{l as Z}from"./layout-C3Rws-0_.js";import{i as S}from"./_baseUniq-BUzPNbzO.js";import{c as $}from"./clone-Dt0APifM.js";import{m as B}from"./_basePickBy-BpDJR12m.js";import"./index-p4Dt6o3z.js";import"./github-hmyLGe0b.js";import"./augment-logo-C66YBCMf.js";import"./TextTooltipAugment-C0ygVke5.js";import"./IconButtonAugment-B0XoCIXT.js";import"./ButtonAugment-DueOA3_V.js";import"./Content-7zb4jZEH.js";import"./globals-D0QH3NT1.js";import"./chat-context-Dq8CyOam.js";import"./pen-to-square-DUXCbbi7.js";import"./file-paths-BEF4tZXQ.js";import"./CollapseButtonAugment-C3mt1EeR.js";import"./toggleHighContrast-CKn954qg.js";import"./preload-helper-Dv6uf1Os.js";import"./keypress-DD1aQVr0.js";import"./await_block-CgSfNRTu.js";import"./circle-backslash-B3nG_JMr.js";import"./expand-Ccnb8uFO.js";import"./index-CkBhOCxh.js";import"./ellipsis-Bz-dObmZ.js";import"./IconFilePath-DrTaSdRG.js";import"./LanguageIcon-e6aGriGL.js";import"./next-edit-types-904A5ehg.js";import"./MaterialIcon-9THX1buP.js";import"./mcp-logo-CiDifGtg.js";import"./play-DmB9WugJ.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return S(e.graph())||(r.value=$(e.graph())),r}function ee(e){return B(e.nodes(),function(r){var n=e.node(r),a=e.parent(r),d={v:r};return S(n)||(d.value=n),S(a)||(d.parent=a),d})}function ne(e){return B(e.edges(),function(r){var n=e.edge(r),a={v:r.v,w:r.w};return S(r.name)||(a.name=r.name),S(n)||(a.value=n),a})}var l=new Map,b=new Map,P=new Map,re=m(()=>{b.clear(),P.clear(),l.clear()},"clear"),D=m((e,r)=>{const n=b.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),te=m((e,r)=>{const n=b.get(r)||[];return i.info("Descendants of ",r," is ",n),i.info("Edge is ",e),e.v!==r&&e.w!==r&&(n?n.includes(e.v)||D(e.v,r)||D(e.w,r)||n.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),A=m((e,r,n,a)=>{i.warn("Copying children of ",e,"root",a,"data",r.node(e),a);const d=r.children(e)||[];e!==a&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(s=>{if(r.children(s).length>0)A(s,r,n,a);else{const o=r.node(s);i.info("cp ",s," to ",a," with parent ",e),n.setNode(s,o),a!==r.parent(s)&&(i.warn("Setting parent",s,r.parent(s)),n.setParent(s,r.parent(s))),e!==a&&s!==e?(i.debug("Setting parent",s,e),n.setParent(s,e)):(i.info("In copy ",e,"root",a,"data",r.node(e),a),i.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==a,"node!==clusterId",s!==e));const c=r.edges(s);i.debug("Copying Edges",c),c.forEach(p=>{i.info("Edge",p);const E=r.edge(p.v,p.w,p.name);i.info("Edge data",E,a);try{te(p,a)?(i.info("Copying as ",p.v,p.w,E,p.name),n.setEdge(p.v,p.w,E,p.name),i.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",a," clusterId:",e)}catch(C){i.error(C)}})}i.debug("Removing node",s),r.removeNode(s)})},"copy"),J=m((e,r)=>{const n=r.children(e);let a=[...n];for(const d of n)P.set(d,e),a=[...a,...J(d,r)];return a},"extractDescendants"),ie=m((e,r,n)=>{const a=e.edges().filter(c=>c.v===r||c.w===r),d=e.edges().filter(c=>c.v===n||c.w===n),s=a.map(c=>({v:c.v===r?n:c.v,w:c.w===r?r:c.w})),o=d.map(c=>({v:c.v,w:c.w}));return s.filter(c=>o.some(p=>c.v===p.v&&c.w===p.w))},"findCommonEdges"),I=m((e,r,n)=>{const a=r.children(e);if(i.trace("Searching children of id ",e,a),a.length<1)return e;let d;for(const s of a){const o=I(s,r,n),c=ie(r,n,o);if(o){if(!(c.length>0))return o;d=o}}return d},"findNonClusterChild"),G=m(e=>l.has(e)&&l.get(e).externalConnections&&l.has(e)?l.get(e).id:e,"getAnchorId"),oe=m((e,r)=>{if(!e||r>10)i.debug("Opting out, no graph ");else{i.debug("Opting in, graph "),e.nodes().forEach(function(n){e.children(n).length>0&&(i.warn("Cluster identified",n," Replacement id in edges: ",I(n,e,n)),b.set(n,J(n,e)),l.set(n,{id:I(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const a=e.children(n),d=e.edges();a.length>0?(i.debug("Cluster identified",n,b),d.forEach(s=>{D(s.v,n)^D(s.w,n)&&(i.warn("Edge: ",s," leaves cluster ",n),i.warn("Descendants of XXX ",n,": ",b.get(n)),l.get(n).externalConnections=!0)})):i.debug("Not a cluster ",n,b)});for(let n of l.keys()){const a=l.get(n).id,d=e.parent(a);d!==n&&l.has(d)&&!l.get(d).externalConnections&&(l.get(n).id=d)}e.edges().forEach(function(n){const a=e.edge(n);i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let d=n.v,s=n.w;if(i.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(i.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),d=G(n.v),s=G(n.w),e.removeEdge(n.v,n.w,n.name),d!==n.v){const o=e.parent(d);l.get(o).externalConnections=!0,a.fromCluster=n.v}if(s!==n.w){const o=e.parent(s);l.get(o).externalConnections=!0,a.toCluster=n.w}i.warn("Fix Replacing with XXX",d,s,n.name),e.setEdge(d,s,a,n.name)}}),i.warn("Adjusted Graph",X(e)),R(e,0),i.trace(l)}},"adjustClustersAndEdges"),R=m((e,r)=>{var d,s;if(i.warn("extractor - ",r,X(e),e.children("D")),r>10)return void i.error("Bailing out");let n=e.nodes(),a=!1;for(const o of n){const c=e.children(o);a=a||c.length>0}if(a){i.debug("Nodes = ",n,r);for(const o of n)if(i.debug("Extracting node",o,l,l.has(o)&&!l.get(o).externalConnections,!e.parent(o),e.node(o),e.children("D")," Depth ",r),l.has(o))if(!l.get(o).externalConnections&&e.children(o)&&e.children(o).length>0){i.warn("Cluster without external connections, without a parent and with children",o,r);let c=e.graph().rankdir==="TB"?"LR":"TB";(s=(d=l.get(o))==null?void 0:d.clusterData)!=null&&s.dir&&(c=l.get(o).clusterData.dir,i.warn("Fixing dir",l.get(o).clusterData.dir,c));const p=new k({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",X(e)),A(o,e,p,o),e.setNode(o,{clusterNode:!0,id:o,clusterData:l.get(o).clusterData,label:l.get(o).label,graph:p}),i.warn("New graph after copy node: (",o,")",X(p)),i.debug("Old graph after copy",X(e))}else i.warn("Cluster ** ",o," **not meeting the criteria !externalConnections:",!l.get(o).externalConnections," no parent: ",!e.parent(o)," children ",e.children(o)&&e.children(o).length>0,e.children("D"),r),i.debug(l);else i.debug("Not a cluster",o,r);n=e.nodes(),i.warn("New list of nodes",n);for(const o of n){const c=e.node(o);i.warn(" Now next level",o,c),c!=null&&c.clusterNode&&R(c.graph,r+1)}}else i.debug("Done, no node has children",e.nodes())},"extractor"),T=m((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(a=>{const d=e.children(a),s=T(e,d);n=[...n,...s]}),n},"sorter"),ae=m(e=>T(e,e.children()),"sortNodesByHierarchy"),L=m(async(e,r,n,a,d,s)=>{i.warn("Graph in recursive render:XAX",X(r),d);const o=r.graph().rankdir;i.trace("Dir in recursive render - dir:",o);const c=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const p=c.insert("g").attr("class","clusters"),E=c.insert("g").attr("class","edgePaths"),C=c.insert("g").attr("class","edgeLabels"),f=c.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){const t=r.node(g);if(d!==void 0){const u=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,u.height,`
Parent cluster`,d.height),r.setNode(d.id,u),r.parent(g)||(i.trace("Setting parent",g,d.id),r.setParent(g,d.id,u))}if(i.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),t==null?void 0:t.clusterNode){i.info("Cluster identified XBX",g,t.width,r.node(g));const{ranksep:u,nodesep:w}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:u+25,nodesep:w});const N=await L(f,t.graph,n,a,r.node(g),s),x=N.elem;z(t,x),t.diff=N.diff||0,i.info("New compound node after recursive render XAX",g,"width",t.width,"height",t.height),_(x,t)}else r.children(g).length>0?(i.trace("Cluster - the non recursive path XBX",g,t.id,t,t.width,"Graph:",r),i.trace(I(t.id,r)),l.set(t.id,{id:I(t.id,r),node:t})):(i.trace("Node - the non recursive path XAX",g,f,r.node(g),o),await q(f,r.node(g),{config:s,dir:o}))})),await m(async()=>{const g=r.edges().map(async function(t){const u=r.edge(t.v,t.w,t.name);i.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),i.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await W(C,u)});await Promise.all(g)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(X(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),Z(r),i.info("Graph after layout:",JSON.stringify(X(r)));let y=0,{subGraphTitleTotalMargin:v}=K(s);return await Promise.all(ae(r).map(async function(g){var u;const t=r.node(g);if(i.info("Position XBX => "+g+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=v,i.info("A tainted cluster node XBX1",g,t.id,t.width,t.height,t.x,t.y,r.parent(g)),l.get(t.id).node=t,O(t);else if(r.children(g).length>0){i.info("A pure cluster node XBX1",g,t.id,t.x,t.y,t.width,t.height,r.parent(g)),t.height+=v,r.node(t.parentId);const w=(t==null?void 0:t.padding)/2||0,N=((u=t==null?void 0:t.labelBBox)==null?void 0:u.height)||0,x=N-w||0;i.debug("OffsetY",x,"labelHeight",N,"halfPadding",w),await Q(p,t),l.get(t.id).node=t}else{const w=r.node(t.parentId);t.y+=v/2,i.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",w,w==null?void 0:w.offsetY,t),O(t)}})),r.edges().forEach(function(g){const t=r.edge(g);i.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(t),t),t.points.forEach(x=>x.y+=v/2);const u=r.node(g.v);var w=r.node(g.w);const N=U(E,t,l,n,u,w,a);V(t,N)}),r.nodes().forEach(function(g){const t=r.node(g);i.info(g,t.type,t.diff),t.isGroup&&(y=t.diff)}),i.warn("Returning from recursive render XAX",c,y),{elem:c,diff:y}},"recursiveRender"),Me=m(async(e,r)=>{var s,o,c,p,E,C;const n=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((c=(o=e.config)==null?void 0:o.flowchart)==null?void 0:c.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((C=(E=e.config)==null?void 0:E.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),a=r.select("g");M(a,e.markers,e.type,e.diagramId),j(),F(),Y(),re(),e.nodes.forEach(f=>{n.setNode(f.id,{...f}),f.parentId&&n.setParent(f.id,f.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(f=>{if(f.start===f.end){const h=f.start,y=h+"---"+h+"---1",v=h+"---"+h+"---2",g=n.node(h);n.setNode(y,{domId:y,id:y,parentId:g.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(y,g.parentId),n.setNode(v,{domId:v,id:v,parentId:g.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(v,g.parentId);const t=structuredClone(f),u=structuredClone(f),w=structuredClone(f);t.label="",t.arrowTypeEnd="none",t.id=h+"-cyclic-special-1",u.arrowTypeEnd="none",u.id=h+"-cyclic-special-mid",w.label="",g.isGroup&&(t.fromCluster=h,w.toCluster=h),w.id=h+"-cyclic-special-2",n.setEdge(h,y,t,h+"-cyclic-special-0"),n.setEdge(y,v,u,h+"-cyclic-special-1"),n.setEdge(v,h,w,h+"-cyc<lic-special-2")}else n.setEdge(f.start,f.end,{...f},f.id)}),i.warn("Graph at first:",JSON.stringify(X(n))),oe(n),i.warn("Graph after XAX:",JSON.stringify(X(n)));const d=H();await L(a,n,e.type,e.diagramId,void 0,d)},"render");export{Me as render};
